<!DOCTYPE HTML>
<html>
    <head>
        <title>Физическое моделирование воды</title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
        <div id="A4">
            <p id="section">
                Физическое моделирование воды
            </p>
            
            <p id="small">
                (https://gamedev.ru/code/articles/?id=4205)
            </p>

            <p id="plane">
                Эффект водной глади является желанным гостем в трехмерной графике. 
                В краткой заметке я попытаюсь рассказать про физическое моделирование. 
                Побудительными мотивами являются следующие обстоятельства. Во-первых,
                довольно абстрактная <i>mIRC</i> лекция <i>Yann L.</i>, посвященная моделированию воды. 
                Безусловно очень компетентного и знающего человека. Однако, 
                в лекции допущены грубые неточности. Его реализация (которая, вопреки 
                заявленному, не имеет к уравнению Навье-Стокса ни малейшего отношения) 
                не является оптимальной с точки зрения сеточных методов решения дифференциальных
                уравнений. В короткий промежуток времени мне на глаза попалось и другое 
                воплощение. Тоже весьма некачественное.
            </p>

            <p id="plane">
                В заметке будет рассказано о самом общеупотребительном сеточном методе решения 
                уравнения колебаний: 
            </p>

            <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                <semantics>
                 <mrow>
                  <mfrac>
                   <mrow>
                    <msup>
                     <mi>d</mi>
                     <mn>2</mn>
                    </msup>
                    <mi>U</mi>
                   </mrow>
                   <msup>
                    <mi mathvariant="italic">dt</mi>
                    <mn>2</mn>
                   </msup>
                  </mfrac>
                  <mo stretchy="false">=</mo>
                  <mrow>
                   <mfrac>
                    <mrow>
                     <msup>
                      <mi>d</mi>
                      <mn>2</mn>
                     </msup>
                     <mi>U</mi>
                    </mrow>
                    <msup>
                     <mi mathvariant="italic">dx</mi>
                     <mn>2</mn>
                    </msup>
                   </mfrac>
                   <mo stretchy="false">+</mo>
                   <mfrac>
                    <mrow>
                     <msup>
                      <mi>d</mi>
                      <mn>2</mn>
                     </msup>
                     <mi>U</mi>
                    </mrow>
                    <msup>
                     <mi mathvariant="italic">dy</mi>
                     <mn>2</mn>
                    </msup>
                   </mfrac>
                  </mrow>
                 </mrow>
                 <annotation encoding="StarMath 5.0">{ d^2 U } over { dt^2 } = { d^2 U } over { dx^2 } + { d^2 U } over { dy^2 }</annotation>
                </semantics>
               </math>

            <p id="plane">
               Здесь <i>t</i> - время, <i>x,y</i> - координаты. Решая это уравнение, мы получим очень 
               реалистичную поверхность воды. Кроме того, в статье будет приведен очень быстрый 
               (и правильный с точки зрения математики) расчет нормалей без вычисления обратного 
               квадратного корня и векторных произведений.
            </p>

            <p id="plane">
                Не надо пугаться страшных непонятных буковок в уравнении (*). Дальнейшее изложение 
                не требует понимания того, что именно там написано.
            </p>

            <p id="plane">
                Итак, некоторые определения: вершина (нормаль и координата), и массив, содержащий числа. 
                Эти самые числа будут интерпретированы как высота поверхности воды в регулярной сетке. 
                Нам надо завести два таких массива, и мы будем переключаться между ними по надобности. 
            </p>

            <p id="code">
            <code>
            struct vertex<br>
            {<br>
            &emsp; float coo[3];<br>
            &emsp; float nor[3];<br>
	        };<br>
            <br>
	        struct field<br>
	        {<br>
            &emsp; float U[128][128];<br>
	        };<br>
            <br>
	        vertex vertices[128][128];<br>
	        field A,B;<br>
            field *p=&A,*n=&B;<br>
            </code>
            </p>

            <p id="tip">
                А вот и основной шаг программы:
            </p>

            <p id="code">
            <code>
            void time_step()<br>
	        {<br>
            &emsp; int i,j,i1,j1;<br>
		    &emsp; i1=rand()%110;<br>
		    &emsp; j1=rand()%110;<br>
		    &emsp; /*1*/<br>
		    &emsp; if((rand()&127)==0)<br>
		    &emsp; for(i=-3;i<4;i++)<br></4>
		    &emsp; {<br>
			&emsp; &emsp; for(j=-3;j<4;j++)<br></4>
			&emsp; &emsp; {<br>
			&emsp; &emsp; float v=6.0f-i*i-j*j;<br>
			&emsp; &emsp; if(v<0.0f)v=0.0f;<br></0.0f>
			&emsp; &emsp; n->U[i+i1+3][j+j1+3]-=v*0.004f;<br>
			}<br>
		    }<br>
		    for(i=1;i<127;i++)<br></127>
		    {<br>
			for(j=1;j<127;j++)<br></127>
			{<br>
			/*2*/<br>
			vertices[i][j].coo[2]=n->U[i][j];<br>
			vertices[i][j].nor[0]=n->U[i-1][j]-n->U[i+1][j];<br>
			vertices[i][j].nor[1]=n->U[i][j-1]-n->U[i][j+1];<br>
			/*3*/<br>
			#define vis 0.005f  <br>
			float laplas=(n->U[i-1][j]+<br>
			n->U[i+1][j]+<br>
			n->U[i][j+1]+<br>
			n->U[i][j-1])*0.25f-n->U[i][j];<br>
  			/*4*/<br>
  			p→U[i][j]=((2.0f-vis)*n→U[i][j]-p→U[i][j]*(1.0f-vis)+laplas);<br>
			}<br>
		    }<br>
		    /*5*/<br>
		    for(i=1;i<127;i++)<br>
		    {<br>
			glBegin(GL_TRIANGLE_STRIP);<br>
			for(j=1;j<127;j++)<br>
			{
			glNormal3fv(vertices[i][j].nor);<br>
			glVertex3fv(vertices[i][j].coo);<br>
			glNormal3fv(vertices[i+1][j].nor);<br>
			glVertex3fv(vertices[i+1][j].coo);<br>
			}<br>
			glEnd();<br>
		    }<br>
		    /*6*/<br>
		    field *sw=p;p=n;n=sw;<br>
	        }<br>
            </code>
            </p>

            <p id="tip">
                
            </p>

            <p id="plane">
               
            </p>
        
            <p id="subsection">
               
            </p>

            <p id="tip">
                
            </p>

            <p id="plane">
                
            </p>
        </page>
    </body>
</html>